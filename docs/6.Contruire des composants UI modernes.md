# Construire des composants UI modernes

Nous allons travailler sur `HomeView.vue`. L'objectif est de r√©cup√©rer les Pok√©mons depuis le backend et de les afficher sous la forme de cartes.

1. Cr√©er le composant `PokemonCard.vue`

    Dans le dossier `src/components`, cr√©ez un nouveau fichier `PokemonCard.vue` (composant r√©utilisable) avec le contenu suivant :

    ```vue
    <script setup>
    // defineProps est l'√©quivalent de "export let" en Svelte
    defineProps({
        pokemon: Object
    });
    </script>

    <template>
        <div class="bg-white rounded-xl shadow-sm hover:shadow-md transition-shadow border border-slate-100 overflow-hidden group">
            <div class="bg-slate-50 h-40 flex items-center justify-center">
                <span class="text-4xl group-hover:scale-110 transition-transform">üêæ</span>
            </div>
            
            <div class="p-4">
                <h3 class="font-bold text-lg text-slate-800 capitalize">{{ pokemon.name }}</h3>
                
                <div class="flex gap-2 mt-2">
                    <span 
                        v-for="type in pokemon.types" 
                        :key="type.id"
                        :style="{ backgroundColor: `#${type.color}` }"
                        class="px-2 py-0.5 rounded text-xs font-semibold text-white shadow-sm"
                        >
                        {{ type.name }}
                    </span>
                </div>
                
                <div class="grid grid-cols-2 gap-2 mt-4 text-xs text-slate-500">
                    <p>PV: <span class="font-semibold">{{ pokemon.hp }}</span></p>
                    <p>ATK: <span class="font-semibold">{{ pokemon.atk }}</span></p>
                </div>
            </div>
        </div>
    </template>
    ```

2. Mettre √† jour `HomeView.vue`

    Maintenant, on appelle notre API et on utilise une boucle pour afficher les cartes de chaque Pok√©mon.

    ```vue
    <script setup>
    import { ref, onMounted } from 'vue';
    import api from '../services/api';
    import PokemonCard from '../components/PokemonCard.vue';

    const pokemons = ref([]);
    const isLoading = ref(true);
    const error = ref(null);

    // onMounted est l'√©quivalent de onMount en Svelte
    onMounted(async () => {
    try {
        const response = await api.get("/pokemons");
        pokemons.value = response.data;
    } catch (err) {
        error.value = "Impossible de charger les Pok√©mons.";
    } finally {
        isLoading.value = false;
    }
    });
    </script>

    <template>
        <div class="p-6">
        <header class="mb-8">
            <h1 class="text-3xl font-extrabold text-slate-900">Pok√©dex National</h1>
            <p class="text-slate-500">Consultez la liste compl√®te des Pok√©mons et leurs statistiques.</p>
        </header>
        
        <div v-if="isLoading" class="flex justify-center py-20">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
        </div>

        <div v-else-if="error" class="bg-red-50 text-red-600 p-4 rounded-lg text-center">
            {{ error }}
        </div>

        <div v-else class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
            <PokemonCard 
                v-for="pokemon in pokemons" 
                :key="pokemon.id" 
                :pokemon="pokemon"
            />
        </div>
        </div>
    </template>
    ```

---

## Concepts importants

- `v-for` : C'est le `{#each}` de Vue. Note l'importance de `:key="pokemon.id"`, c'est indispensable pour que Vue sache quel √©l√©ment mettre √† jour si la liste change.

- Les classes Tailwind :
  - ``grid-cols-1 sm:grid-cols-2 md:grid-cols-4`` : C'est le secret du responsive. 1 colonne sur mobile, 2 sur tablette, 4 sur ordinateur.

  - ``animate-spin`` : Une classe utilitaire Tailwind qui cr√©e une animation de chargement instantan√©ment.

- Le style dynamique : `:style="{ backgroundColor: '#' + type.color }"` permet d'injecter du CSS venant directement de ta base de donn√©es.

---

**Pourquoi c'est "sobre et moderne" ?**

On utilise une palette de gris (`slate`), des coins arrondis (`rounded-xl`), et des transitions douces au survol (`hover:shadow-md`). C'est le look "SaaS" moderne par excellence.
